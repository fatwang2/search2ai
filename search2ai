addEventListener('fetch', event => {
    const url = new URL(event.request.url);
    if (url.pathname === '/v1/chat/completions') {
        console.log('æ¥æ”¶åˆ° fetch äº‹ä»¶');
        event.respondWith(handleRequest(event.request));
    } else {
        console.log('è¯·æ±‚çš„è·¯å¾„ä¸æ˜¯ /v1/chat/completionsï¼Œè¿”å›404çŠ¶æ€ç ');
        event.respondWith(new Response('Not found', {status: 404}));
    }
})

// æœç´¢å‡½æ•°ï¼Œè°ƒç”¨æ‚¨çš„æœç´¢æœåŠ¡
async function custom_search(query) {
    console.log(`æ­£åœ¨ä½¿ç”¨æŸ¥è¯¢è¿›è¡Œè‡ªå®šä¹‰æœç´¢: ${query}`);
    try {
        const response = await fetch('https://gpts.webpilot.ai/api/visit-web', {
            method: 'POST',
            headers: { "Content-Type": "application/json", "WebPilot-Friend-UID": "fatwang2" },
            body: JSON.stringify({ ur: query })
        });

        if (!response.ok) {
            console.error(`API è¯·æ±‚å¤±è´¥, çŠ¶æ€ç : ${response.status}`);
            return `API è¯·æ±‚å¤±è´¥, çŠ¶æ€ç : ${response.status}`;
        }

        const contentType = response.headers.get("content-type");
        if (!contentType || !contentType.includes("application/json")) {
            console.error("æ”¶åˆ°çš„å“åº”ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼");
            return "æ”¶åˆ°çš„å“åº”ä¸æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼";
        }

        const data = await response.json();
        console.log('è‡ªå®šä¹‰æœç´¢æœåŠ¡è°ƒç”¨å®Œæˆ');
        return JSON.stringify(data.content);
    } catch (error) {
        console.error('è¯·æ±‚è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
        return 'è¯·æ±‚è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯';
    }
}


async function handleRequest(request) {
    // @ts-ignore
    const apiBase = typeof APIBASE !== 'undefined' ? APIBASE : 'https://api.openai.com';

    // åœ¨å‡½æ•°çš„å¼€å§‹éƒ¨åˆ†
    if (request.method === 'OPTIONS') {
        // é¢„æ£€è¯·æ±‚ã€‚å›åº”æ‰€æœ‰çš„é¢„æ£€è¯·æ±‚ï¼Œå¹¶è®¾ç½®é€‚å½“çš„`Access-Control-Allow-*`å¤´éƒ¨
        return new Response(null, {
            headers: {
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type, Authorization'
            }
        });
    }
    console.log('è¯·æ±‚æ–¹æ³•:', request.method);
    console.log('è¯·æ±‚å¤´:', [...request.headers]);
    const requestData = await request.json();
    console.log('è¯·æ±‚ä½“:', requestData);
    // æ‰¾åˆ°æœ€æ–°çš„ç”¨æˆ·æ¶ˆæ¯
    const userMessages = requestData.messages.filter(message => message.role === 'user');
    const latestUserMessage = userMessages[userMessages.length - 1];
    const user_input = latestUserMessage ? latestUserMessage.content : "";
    console.log(`ç”¨æˆ·è¾“å…¥: ${user_input}`);
    // è®¾ç½®é»˜è®¤å€¼
    const defaultModel = "gpt-3.5-turbo-1106";
    const defaultSystemContent = "You are a helpful assistant.";

    const model = requestData.model || defaultModel; // ä½¿ç”¨é»˜è®¤ model å¦‚æœæœªæä¾›
    const system_content = requestData.messages[0]?.content || defaultSystemContent; // ä½¿ç”¨é»˜è®¤ system_content å¦‚æœæœªæä¾›
    const authHeader = request.headers.get('Authorization'); // ä»è¯·æ±‚çš„ headers ä¸­è·å– Authorization
    const apiKey = authHeader.split(' ')[1]; // ä» Authorization ä¸­è·å– API key
    const body = JSON.stringify({
        model: model,
        messages: [
        { role: "system", content: system_content},
        { role: "user", content: user_input }
        ],
        tools: [
        {
            type: "function",
            function: {
            name: "custom_search",
            description: "search online for news and factors",
            parameters: {
                type: "object",
                properties: {
                    query: { type: "string" }
                },
                required: ["query"]
                }
            }
        }
    ],
    tool_choice: "auto"
});

    console.log('è§£æè¯·æ±‚æ–‡æœ¬å®Œæˆï¼Œå‡†å¤‡è°ƒç”¨ OpenAI API');
    const openAIResponse = await fetch(`${apiBase}/v1/chat/completions`, {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': `Bearer ${apiKey}` // ä½¿ç”¨ä»è¯·æ±‚çš„ headers ä¸­è·å–çš„ API key
        },
        body: body
    });
    console.log('OpenAI API è¯·æ±‚ä½“:', body);
    const data = await openAIResponse.json();
    console.log('OpenAI API å“åº”çŠ¶æ€ç :', openAIResponse.status);
    console.log('OpenAI API å“åº”å¤´:', openAIResponse.headers);
    console.log('OpenAI API å“åº”ä½“:', data);
    if (!data.choices || data.choices.length === 0) {
        console.log('æ•°æ®ä¸­æ²¡æœ‰é€‰æ‹©é¡¹');
        return new Response('æ•°æ®ä¸­æ²¡æœ‰é€‰æ‹©é¡¹', { status: 500 });
    }
    
    console.log('OpenAI API å“åº”æ¥æ”¶å®Œæˆï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è°ƒç”¨è‡ªå®šä¹‰å‡½æ•°');
    let messages = requestData.messages;
    messages.push(data.choices[0].message);
    // æ£€æŸ¥æ˜¯å¦æœ‰å‡½æ•°è°ƒç”¨
    let calledCustomFunction = false;
    if (data.choices[0].message.tool_calls) {
        const toolCalls = data.choices[0].message.tool_calls;
        const availableFunctions = {
            custom_search: custom_search,
        };

        
        for (const toolCall of toolCalls) {
            const functionName = toolCall.function.name;
            const functionToCall = availableFunctions[functionName];
            const functionArgs = JSON.parse(toolCall.function.arguments);
            const functionResponse = await functionToCall(functionArgs.query);
            messages.push({
                tool_call_id: toolCall.id,
                role: "tool",
                name: functionName,
                content: functionResponse, 
            });
            if (functionName === "custom_search") {
                calledCustomFunction = true;
            }
        }
        const secondResponse = await fetch(`${apiBase}/v1/chat/completions`, {
            method: 'POST',
            headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Authorization': `Bearer ${apiKey}` // ä½¿ç”¨ä»è¯·æ±‚çš„ headers ä¸­è·å–çš„ API key
            },
            body: JSON.stringify({
                model: model,
                messages: messages
        })
        });
        const secondData = await secondResponse.json();
        // å¦‚æœè°ƒç”¨äº†è‡ªå®šä¹‰å‡½æ•°ï¼Œåˆ™åœ¨æœ€ç»ˆçš„å›å¤ä¸­æ·»åŠ  "ğŸŒ" æ ‡è®°
        if (calledCustomFunction && secondData.choices && secondData.choices.length > 0) {
            secondData.choices[0].message.content = "ğŸŒ" + secondData.choices[0].message.content;
        }
        console.log('å“åº”çŠ¶æ€ç : 200');
        console.log('å“åº”ä½“:', JSON.stringify(secondData));
        return new Response(JSON.stringify(secondData), {
            status: 200,
            headers: { 
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*', // å…è®¸æ¥è‡ªæ‰€æœ‰æºçš„è¯·æ±‚
                'Access-Control-Allow-Methods': 'GET, POST', // å…è®¸ GET å’Œ POST è¯·æ±‚
                'Access-Control-Allow-Headers': 'Content-Type, Authorization' // å…è®¸ Content-Type å’Œ Authorization å¤´éƒ¨
            }
        });
    } else {
        // æ²¡æœ‰è°ƒç”¨è‡ªå®šä¹‰å‡½æ•°ï¼Œç›´æ¥è¿”å›åŸå§‹å›å¤
        console.log('å“åº”çŠ¶æ€ç : 200');
        console.log('å“åº”ä½“:', JSON.stringify(data));
        return new Response(JSON.stringify(data), {
            status: 200,
            headers: { 
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*', // å…è®¸æ¥è‡ªæ‰€æœ‰æºçš„è¯·æ±‚
                'Access-Control-Allow-Methods': 'GET, POST', // å…è®¸ GET å’Œ POST è¯·æ±‚
                'Access-Control-Allow-Headers': 'Content-Type, Authorization' // å…è®¸ Content-Type å’Œ Authorization å¤´éƒ¨
            }
        }); 
    }
}